#### Leetcode 每日一个算法题 (20200415 ~ 20200501 在 everyday-algorithm 项目中) 

---
##### 简单.[@20200503](./_20200503/main.go).[README.md](./_20200503/README.md).[官方题解](./_20200503/Official_Solution.md) [😄me](./_20200503/me.go)
```$xslt
最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```
---
##### 困难.[@20200504](./_20200504/main.go).[README.md](./_20200504/README.md).[官方题解](./_20200504/Official_Solution.md) [😄me](./_20200504/me.go)
```$xslt
跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
```
---
##### 中等.[@20200505](./_20200505/main.go).[README.md](./_20200505/README.md).[官方题解](./_20200505/Official_Solution.md) [😄me](./_20200505/me.go)
```$xslt
验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
```
---
##### 中等.[@20200506](./_20200506/main.go).[README.md](./_20200506/README.md).[官方题解](./_20200506/Official_Solution.md) [😭me](./_20200506/me.go)
```$xslt
最低票价
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
- 一张为期一天的通行证售价为 costs[0] 美元；
- 一张为期七天的通行证售价为 costs[1] 美元；
- 一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
```
---
##### 简单.[@20200507](./_20200507/main.go).[README.md](./_20200507/README.md).[官方题解](./_20200507/Official_Solution.md) [😭me](./_20200507/me.go)
```$xslt
另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
```
---
##### 中等.[@20200508](./_20200508/main.go).[README.md](./_20200508/README.md).[官方题解](./_20200508/Official_Solution.md) [😄me](./_20200508/me.go)
```$xslt
最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
```
---
##### 简单.[@20200509](./_20200509/main.go).[README.md](./_20200509/README.md).[官方题解](./_20200509/Official_Solution.md) [😄me](./_20200509/me.go)
```$xslt
 x 的平方根
实现 `int sqrt(int x)` 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
```
---
##### 中等.[@20200510](./_20200510/main.go).[README.md](./_20200510/README.md).[官方题解](./_20200510/Official_Solution.md) [😄me](./_20200510/me.go)
```$xslt
二叉树的最近公共祖先 
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```
---
##### 中等.[@20200511](./_20200511/main.go).[README.md](./_20200511/README.md).[官方题解](./_20200511/Official_Solution.md) [😄me](./_20200511/me.go)
```$xslt
Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。
```
---
##### 简单.[@20200512](./_20200512/main.go).[README.md](./_20200512/README.md).[官方题解](./_20200512/Official_Solution.md) [😄me](./_20200512/me.go)
```$xslt
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。
```
---
##### 中等.[@20200513](./_20200513/main.go).[README.md](./_20200513/README.md).[官方题解](./_20200513/Official_Solution.md) [😄me](./_20200513/me.go)
```$xslt
二叉树的层序遍历
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
```
---
##### 简单.[@20200514](./_20200514/main.go).[README.md](./_20200514/README.md).[官方题解](./_20200514/Official_Solution.md) [😄me](./_20200514/me.go)
```$xslt
只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
---
##### 中等.[@20200515](./_20200515/main.go).[README.md](./_20200515/README.md).[官方题解](./_20200515/Official_Solution.md) [😄me](./_20200515/me.go)
```$xslt
和为K的子数组
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
```
---
##### 中等.[@20200517](./_20200517/main.go).[README.md](./_20200517/README.md).[官方题解](./_20200517/Official_Solution.md) [😄me](./_20200517/me.go)
```$xslt
课程表 II
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
```
---
##### 中等.[@20200518](./_20200518/main.go).[README.md](./_20200518/README.md).[官方题解](./_20200518/Official_Solution.md) [😄me](./_20200518/me.go)
```$xslt
乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```
---
##### 简单.[@20200519](./_20200519/main.go).[README.md](./_20200519/README.md).[官方题解](./_20200519/Official_Solution.md) [😄me](./_20200519/me.go)
```$xslt
验证回文字符串 Ⅱ
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
```
---
##### 中等.[@20200520](./_20200520/main.go).[README.md](./_20200520/README.md).[官方题解](./_20200520/Official_Solution.md) [😄me](./_20200520/me.go)
```$xslt
每个元音包含偶数次的最长子字符串
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
```
---
##### 中等.[@20200521](./_20200521/main.go).[README.md](./_20200521/README.md).[官方题解](./_20200521/Official_Solution.md) [😄me](./_20200521/me.go)
```$xslt
最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```
---
##### 中等.[@20200522](./_20200522/main.go).[README.md](./_20200522/README.md).[官方题解](./_20200522/Official_Solution.md) [😄me](./_20200522/me.go)
```$xslt
从前序与中序遍历序列构造二叉树
根据一棵树的前序遍历与中序遍历构造二叉树。
```
---
##### 困难.[@20200524](./_20200524/main.go).[README.md](./_20200524/README.md).[官方题解](./_20200524/Official_Solution.md) [😄me](./_20200524/me.go)
```$xslt
寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
```
---
##### 中等.[@20200526](./_20200526/main.go).[README.md](./_20200526/README.md).[官方题解](./_20200526/Official_Solution.md) [😄me](./_20200526/me.go)
```$xslt
寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
```
---
##### 中等.[@20200527](./_20200527/main.go).[README.md](./_20200527/README.md).[官方题解](./_20200527/Official_Solution.md) [😄me](./_20200527/me.go)
```$xslt
和可被 K 整除的子数组
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
```
---
##### 困难.[@20200530](./_20200530/main.go).[README.md](./_20200530/README.md).[官方题解](./_20200530/Official_Solution.md) [😄me](./_20200530/me.go)
```$xslt
柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
```
---
##### 简单.[@20200531](./_20200531/main.go).[README.md](./_20200531/README.md).[官方题解](./_20200531/Official_Solution.md) [😄me](./_20200531/me.go)
```$xslt
对称二叉树
给定一个二叉树，检查它是否是镜像对称的。
```
---
##### 简单.[@20200601](./_20200601/main.go).[README.md](./_20200601/README.md).[官方题解](./_20200601/Official_Solution.md) [😄me](./_20200601/me.go)
```$xslt
拥有最多糖果的孩子
给你一个数组 `candies` 和一个整数 `extraCandies` ，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。
对每一个孩子，检查是否存在一种方案，将额外的 `extraCandies` 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。
```
---
##### 中等.[@20200602](./_20200602/main.go).[README.md](./_20200602/README.md).[官方题解](./_20200602/Official_Solution.md) [😄me](./_20200602/me.go)
```$xslt
面试题64. 求1+2+…+n
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```
---
##### 中等.[@20200603](./_20200603/main.go).[README.md](./_20200603/README.md).[官方题解](./_20200603/Official_Solution.md) [😄me](./_20200603/me.go)
```$xslt
新21点
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？
```
---
##### 中等.[@20200604](./_20200604/main.go).[README.md](./_20200604/README.md).[官方题解](./_20200604/Official_Solution.md) [😄me](./_20200604/me.go)
```$xslt
除自身以外数组的乘积
给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
```
---
##### 简单.[@20200605](./_20200605/main.go).[README.md](./_20200605/README.md).[官方题解](./_20200605/Official_Solution.md) [😄me](./_20200605/me.go)
```$xslt
顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
```
---
##### 困难.[@20200606](./_20200606/main.go).[README.md](./_20200606/README.md).[官方题解](./_20200606/Official_Solution.md) [😄me](./_20200606/me.go)
```$xslt
最长连续序列
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
```
---
##### 中等.[@20200608](./_20200608/main.go).[README.md](./_20200608/README.md).[官方题解](./_20200608/Official_Solution.md) [😄me](./_20200608/me.go)
```$xslt
等式方程的可满足性
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
```
---
##### 中等.[@20200609](./_20200609/main.go).[README.md](./_20200609/README.md).[官方题解](./_20200609/Official_Solution.md) [😄me](./_20200609/me.go)
```$xslt
把数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
```
---
##### 简单.[@20200610](./_20200610/main.go).[README.md](./_20200610/README.md).[官方题解](./_20200610/Official_Solution.md) [😄me](./_20200610/me.go)
```$xslt
回文数
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
```
---
##### 中等.[@20200611](./_20200611/main.go).[README.md](./_20200611/README.md).[官方题解](./_20200611/Official_Solution.md) [😄me](./_20200611/me.go)
```$xslt
每日温度
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。
提示：气温 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。
```
