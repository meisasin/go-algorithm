#### Leetcode 每日一个算法题 (20200415 ~ 20200501 在 everyday-algorithm 项目中) 

---
##### 简单.[@20200503](./_20200503/main.go).[README.md](./_20200503/README.md).[官方题解](./_20200503/Official_Solution.md) [😄me](./_20200503/me.go)
```$xslt
最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```
---
##### 困难.[@20200504](./_20200504/main.go).[README.md](./_20200504/README.md).[官方题解](./_20200504/Official_Solution.md) [😄me](./_20200504/me.go)
```$xslt
跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
```
---
##### 中等.[@20200505](./_20200505/main.go).[README.md](./_20200505/README.md).[官方题解](./_20200505/Official_Solution.md) [😄me](./_20200505/me.go)
```$xslt
验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
```
---
##### 中等.[@20200506](./_20200506/main.go).[README.md](./_20200506/README.md).[官方题解](./_20200506/Official_Solution.md) [😭me](./_20200506/me.go)
```$xslt
最低票价
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
- 一张为期一天的通行证售价为 costs[0] 美元；
- 一张为期七天的通行证售价为 costs[1] 美元；
- 一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
```
---
##### 简单.[@20200507](./_20200507/main.go).[README.md](./_20200507/README.md).[官方题解](./_20200507/Official_Solution.md) [😭me](./_20200507/me.go)
```$xslt
另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
```
---
##### 中等.[@20200508](./_20200508/main.go).[README.md](./_20200508/README.md).[官方题解](./_20200508/Official_Solution.md) [😄me](./_20200508/me.go)
```$xslt
最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
```
---
##### 简单.[@20200509](./_20200509/main.go).[README.md](./_20200509/README.md).[官方题解](./_20200509/Official_Solution.md) [😄me](./_20200509/me.go)
```$xslt
 x 的平方根
实现 `int sqrt(int x)` 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
```
---
##### 中等.[@20200510](./_20200510/main.go).[README.md](./_20200510/README.md).[官方题解](./_20200510/Official_Solution.md) [😄me](./_20200510/me.go)
```$xslt
二叉树的最近公共祖先 
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```
---
##### 中等.[@20200511](./_20200511/main.go).[README.md](./_20200511/README.md).[官方题解](./_20200511/Official_Solution.md) [😄me](./_20200511/me.go)
```$xslt
Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。
```
---
##### 简单.[@20200512](./_20200512/main.go).[README.md](./_20200512/README.md).[官方题解](./_20200512/Official_Solution.md) [😄me](./_20200512/me.go)
```$xslt
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。
```
---
##### 中等.[@20200513](./_20200513/main.go).[README.md](./_20200513/README.md).[官方题解](./_20200513/Official_Solution.md) [😄me](./_20200513/me.go)
```$xslt
二叉树的层序遍历
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
```
---
##### 简单.[@20200514](./_20200514/main.go).[README.md](./_20200514/README.md).[官方题解](./_20200514/Official_Solution.md) [😄me](./_20200514/me.go)
```$xslt
只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
---
##### 中等.[@20200515](./_20200515/main.go).[README.md](./_20200515/README.md).[官方题解](./_20200515/Official_Solution.md) [😄me](./_20200515/me.go)
```$xslt
和为K的子数组
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
```
---
##### 中等.[@20200517](./_20200517/main.go).[README.md](./_20200517/README.md).[官方题解](./_20200517/Official_Solution.md) [😄me](./_20200517/me.go)
```$xslt
课程表 II
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
```
---
##### 中等.[@20200518](./_20200518/main.go).[README.md](./_20200518/README.md).[官方题解](./_20200518/Official_Solution.md) [😄me](./_20200518/me.go)
```$xslt
乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```
---
##### 简单.[@20200519](./_20200519/main.go).[README.md](./_20200519/README.md).[官方题解](./_20200519/Official_Solution.md) [😄me](./_20200519/me.go)
```$xslt
验证回文字符串 Ⅱ
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
```
---
##### 中等.[@20200520](./_20200520/main.go).[README.md](./_20200520/README.md).[官方题解](./_20200520/Official_Solution.md) [😄me](./_20200520/me.go)
```$xslt
每个元音包含偶数次的最长子字符串
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
```
---
##### 中等.[@20200521](./_20200521/main.go).[README.md](./_20200521/README.md).[官方题解](./_20200521/Official_Solution.md) [😄me](./_20200521/me.go)
```$xslt
最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```
---
##### 中等.[@20200522](./_20200522/main.go).[README.md](./_20200522/README.md).[官方题解](./_20200522/Official_Solution.md) [😄me](./_20200522/me.go)
```$xslt
从前序与中序遍历序列构造二叉树
根据一棵树的前序遍历与中序遍历构造二叉树。
```
---
##### 困难.[@20200524](./_20200524/main.go).[README.md](./_20200524/README.md).[官方题解](./_20200524/Official_Solution.md) [😄me](./_20200524/me.go)
```$xslt
寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
```
---
##### 中等.[@20200526](./_20200526/main.go).[README.md](./_20200526/README.md).[官方题解](./_20200526/Official_Solution.md) [😄me](./_20200526/me.go)
```$xslt
寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
```
---
##### 中等.[@20200527](./_20200527/main.go).[README.md](./_20200527/README.md).[官方题解](./_20200527/Official_Solution.md) [😄me](./_20200527/me.go)
```$xslt
和可被 K 整除的子数组
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
```
---
##### 困难.[@20200530](./_20200530/main.go).[README.md](./_20200530/README.md).[官方题解](./_20200530/Official_Solution.md) [😄me](./_20200530/me.go)
```$xslt
柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
```
---
##### 简单.[@20200531](./_20200531/main.go).[README.md](./_20200531/README.md).[官方题解](./_20200531/Official_Solution.md) [😄me](./_20200531/me.go)
```$xslt
对称二叉树
给定一个二叉树，检查它是否是镜像对称的。
```
---
##### 简单.[@20200601](./_20200601/main.go).[README.md](./_20200601/README.md).[官方题解](./_20200601/Official_Solution.md) [😄me](./_20200601/me.go)
```$xslt
拥有最多糖果的孩子
给你一个数组 `candies` 和一个整数 `extraCandies` ，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。
对每一个孩子，检查是否存在一种方案，将额外的 `extraCandies` 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。
```
---
##### 中等.[@20200602](./_20200602/main.go).[README.md](./_20200602/README.md).[官方题解](./_20200602/Official_Solution.md) [😄me](./_20200602/me.go)
```$xslt
面试题64. 求1+2+…+n
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```
---
##### 中等.[@20200603](./_20200603/main.go).[README.md](./_20200603/README.md).[官方题解](./_20200603/Official_Solution.md) [😄me](./_20200603/me.go)
```$xslt
新21点
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？
```
---
##### 中等.[@20200604](./_20200604/main.go).[README.md](./_20200604/README.md).[官方题解](./_20200604/Official_Solution.md) [😄me](./_20200604/me.go)
```$xslt
除自身以外数组的乘积
给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
```
---
##### 简单.[@20200605](./_20200605/main.go).[README.md](./_20200605/README.md).[官方题解](./_20200605/Official_Solution.md) [😄me](./_20200605/me.go)
```$xslt
顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
```
---
##### 困难.[@20200606](./_20200606/main.go).[README.md](./_20200606/README.md).[官方题解](./_20200606/Official_Solution.md) [😄me](./_20200606/me.go)
```$xslt
最长连续序列
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
```
---
##### 中等.[@20200608](./_20200608/main.go).[README.md](./_20200608/README.md).[官方题解](./_20200608/Official_Solution.md) [😄me](./_20200608/me.go)
```$xslt
等式方程的可满足性
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
```
---
##### 中等.[@20200609](./_20200609/main.go).[README.md](./_20200609/README.md).[官方题解](./_20200609/Official_Solution.md) [😄me](./_20200609/me.go)
```$xslt
把数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
```
---
##### 简单.[@20200610](./_20200610/main.go).[README.md](./_20200610/README.md).[官方题解](./_20200610/Official_Solution.md) [😄me](./_20200610/me.go)
```$xslt
回文数
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
```
---
##### 中等.[@20200611](./_20200611/main.go).[README.md](./_20200611/README.md).[官方题解](./_20200611/Official_Solution.md) [😄me](./_20200611/me.go)
```$xslt
每日温度
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。
提示：气温 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。
```
---
##### 中等.[@20200612](./_20200612/main.go).[README.md](./_20200612/README.md).[官方题解](./_20200612/Official_Solution.md) [😄me](./_20200612/me.go)
```$xslt
三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
```
---
##### 简单.[@20200613](./_20200613/main.go).[README.md](./_20200613/README.md).[官方题解](./_20200613/Official_Solution.md) [😄me](./_20200613/me.go)
```$xslt
爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
```
---
##### 简单.[@20200615](./_20200615/main.go).[README.md](./_20200615/README.md).[官方题解](./_20200615/Official_Solution.md) [😄me](./_20200615/me.go)
```$xslt
最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。
```
---
##### 中等.[@20200617](./_20200617/main.go).[README.md](./_20200617/README.md).[官方题解](./_20200617/Official_Solution.md) [😄me](./_20200617/me.go)
```$xslt
最佳观光组合
给定正整数数组 `A`，`A[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的距离为 `j - i`。
一对景点`（i < j）`组成的观光组合的得分为`（A[i] + A[j] + i - j）`：景点的评分之和减去它们两者之间的距离。
返回一对观光景点能取得的最高分。
```
---
##### 困难.[@20200618](./_20200618/main.go).[README.md](./_20200618/README.md).[官方题解](./_20200618/Official_Solution.md) [😄me](./_20200618/me.go)
```$xslt
我们从二叉树的根节点 root 开始进行深度优先搜索。
在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。
如果节点只有一个子节点，那么保证该子节点为左子节点。
给出遍历输出 S，还原树并返回其根节点 root。
```
---
##### 简单.[@20200619](./_20200619/main.go).[README.md](./_20200619/README.md).[官方题解](./_20200619/Official_Solution.md) [😄me](./_20200619/me.go)
```$xslt
验证回文串
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
```
---
##### 困难.[@20200621](./_20200621/main.go).[README.md](./_20200621/README.md).[官方题解](./_20200621/Official_Solution.md) [😄me](./_20200621/me.go)
```$xslt
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
```
---
##### 中等.[@20200622](./_20200622/main.go).[README.md](./_20200622/README.md).[官方题解](./_20200622/Official_Solution.md) [😄me](./_20200622/me.go)
```$xslt
面试题 16.18. 模式匹配
你有两个字符串，即`pattern`和`value`。 
`pattern`字符串由字母`"a"`和`"b"`组成，用于描述字符串中的模式。
例如，字符串`"catcatgocatgo"`匹配模式`"aabab"`（其中`"cat"`是`"a"`，`"go"`是`"b"`），该字符串也匹配像`"a"`、`"ab"`和`"b"`这样的模式。
但需注意`"a"`和`"b"`不能同时表示相同的字符串。编写一个方法判断`value`字符串是否匹配`pattern`字符串。
```
---
##### 简单.[@20200623](./_20200623/main.go).[README.md](./_20200623/README.md).[官方题解](./_20200623/Official_Solution.md) [😄me](./_20200623/me.go)
```$xslt
二进制求和
给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 `1` 和 `0`。
```
---
##### 中等.[@20200624](./_20200624/main.go).[README.md](./_20200624/README.md).[官方题解](./_20200624/Official_Solution.md) [😄me](./_20200624/me.go)
```$xslt
最接近的三数之和
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。
返回这三个数的和。假定每组输入只存在唯一答案。
```
---
##### 中等.[@20200625](./_20200625/main.go).[README.md](./_20200625/README.md).[官方题解](./_20200625/Official_Solution.md) [😄me](./_20200625/me.go)
```$xslt
单词拆分
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
```
---
##### 简单.[@20200626](./_20200626/main.go).[README.md](./_20200626/README.md).[官方题解](./_20200626/Official_Solution.md) [😄me](./_20200626/me.go)
```$xslt
面试题 02.01. 移除重复节点
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
```
---
##### 困难.[@20200627](./_20200627/main.go).[README.md](./_20200627/README.md).[官方题解](./_20200627/Official_Solution.md) [😄me](./_20200627/me.go)
```$xslt
缺失的第一个正数
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
```
---
##### 中等.[@20200628](./_20200628/main.go).[README.md](./_20200628/README.md).[官方题解](./_20200628/Official_Solution.md) [😄me](./_20200628/me.go)
```$xslt
长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。
```
---
##### 中等.[@20200629](./_20200629/main.go).[README.md](./_20200629/README.md).[官方题解](./_20200629/Official_Solution.md) [😄me](./_20200629/me.go)
```$xslt
数组中的第K个最大元素
在未排序的数组中找到第 `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
```
---
##### 简单.[@20200630](./_20200630/main.go).[README.md](./_20200630/README.md).[官方题解](./_20200630/Official_Solution.md) [😄me](./_20200630/me.go)
```$xslt
剑指 Offer 09. 用两个栈实现队列
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，
分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
```
---
##### 中等.[@20200701](./_20200701/main.go).[README.md](./_20200701/README.md).[官方题解](./_20200701/Official_Solution.md) [😄me](./_20200701/me.go)
```$xslt
最长重复子数组
给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。
```
---
##### 中等.[@20200702](./_20200702/main.go).[README.md](./_20200702/README.md).[官方题解](./_20200702/Official_Solution.md) [😄me](./_20200702/me.go)
```$xslt
有序矩阵中第K小的元素
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
```
---
##### 简单.[@20200703](./_20200703/main.go).[README.md](./_20200703/README.md).[官方题解](./_20200703/Official_Solution.md) [😄me](./_20200703/me.go)
```$xslt
将有序数组转换为二叉搜索树
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
```
---
##### 困难.[@20200704](./_20200704/main.go).[README.md](./_20200704/README.md).[官方题解](./_20200704/Official_Solution.md) [😄me](./_20200704/me.go)
```$xslt
最长有效括号
给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。
```
---
##### 困难.[@20200705](./_20200705/main.go).[README.md](./_20200705/README.md).[官方题解](./_20200705/Official_Solution.md) [😄me](./_20200705/me.go)
```$xslt
通配符匹配
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
```
---
##### 中等.[@20200706](./_20200706/main.go).[README.md](./_20200706/README.md).[官方题解](./_20200706/Official_Solution.md) [😄me](./_20200706/me.go)
```$xslt
不同路径 II
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
*说明*：m 和 n 的值均不超过 100。
```
---
##### 简单.[@20200707](./_20200707/main.go).[README.md](./_20200707/README.md).[官方题解](./_20200707/Official_Solution.md) [😄me](./_20200707/me.go)
```$xslt
路径总和
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
```
---
##### 简单.[@20200708](./_20200708/main.go).[README.md](./_20200708/README.md).[官方题解](./_20200708/Official_Solution.md) [😄me](./_20200708/me.go)
```$xslt
面试题 16.11. 跳水板
你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。
你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。
```
---
##### 中等.[@20200709](./_20200709/main.go).[README.md](./_20200709/README.md).[官方题解](./_20200709/Official_Solution.md) [😄me](./_20200709/me.go)
```$xslt
面试题 17.13. 恢复空格
哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。
在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。
注意：本题相对原题稍作改动，只需返回未识别的字符数
```
---
##### 中等.[@20200710](./_20200710/main.go).[README.md](./_20200710/README.md).[官方题解](./_20200710/Official_Solution.md) [😄me](./_20200710/me.go)
```$xslt
309. 最佳买卖股票时机含冷冻期
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
```
---
##### 困难.[@20200711](./_20200711/main.go).[README.md](./_20200711/README.md).[官方题解](./_20200711/Official_Solution.md) [😄me](./_20200711/me.go)
```$xslt
315. 计算右侧小于当前元素的个数
给定一个整数数组 `nums`，按要求返回一个新数组 `counts`。数组 `counts` 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
```
---
##### 困难.[@20200712](./_20200712/main.go).[README.md](./_20200712/README.md).[官方题解](./_20200712/Official_Solution.md) [😄me](./_20200712/me.go)
```$xslt
174. 地下城游戏
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 `M x N` 个房间组成的二维网格。
我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；
其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。
*编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。*
```
---
##### 简单.[@20200713](./_20200713/main.go).[README.md](./_20200713/README.md).[官方题解](./_20200713/Official_Solution.md) [😄me](./_20200713/me.go)
```$xslt
350. 两个数组的交集 II
给定两个数组，编写一个函数来计算它们的交集。
```
---
##### 中等.[@20200714](./_20200714/main.go).[README.md](./_20200714/README.md).[官方题解](./_20200714/Official_Solution.md) [😄me](./_20200714/me.go)
```$xslt
120. 三角形最小路径和
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
```
---
##### 中等.[@20200715](./_20200715/main.go).[README.md](./_20200715/README.md).[官方题解](./_20200715/Official_Solution.md) [😄me](./_20200715/me.go)
```$xslt
96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
```
---
##### 中等.[@20200716](./_20200716/main.go).[README.md](./_20200716/README.md).[官方题解](./_20200716/Official_Solution.md) [😄me](./_20200716/me.go)
```$xslt
785. 判断二分图
给定一个无向图`graph`，当这个图为二分图时返回`true`。
如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。
`graph`将会以邻接表方式给出，`graph[i]`表示图中与节点`i`相连的所有节点。每个节点都是一个在`0`到`graph.length-1`之间的整数。这图中没有自环和平行边： 
`graph[i]` 中不存在i，并且`graph[i]`中没有重复的值。
```
---
##### 简单.[@20200717](./_20200717/main.go).[README.md](./_20200717/README.md).[官方题解](./_20200717/Official_Solution.md) [😄me](./_20200717/me.go)
```$xslt
35. 搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
```



