#### Leetcode 每日一个算法题 (20200415 ~ 20200501 在 everyday-algorithm 项目中) 

---
##### 简单.[@20200503](./_20200503/main.go).[README.md](./_20200503/README.md).[官方题解](./_20200503/Official_Solution.md) [😄me](./_20200503/me.go)
```$xslt
最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
```
---
##### 困难.[@20200504](./_20200504/main.go).[README.md](./_20200504/README.md).[官方题解](./_20200504/Official_Solution.md) [😄me](./_20200504/me.go)
```$xslt
跳跃游戏 II
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
```
---
##### 中等.[@20200505](./_20200505/main.go).[README.md](./_20200505/README.md).[官方题解](./_20200505/Official_Solution.md) [😄me](./_20200505/me.go)
```$xslt
验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
```
---
##### 中等.[@20200506](./_20200506/main.go).[README.md](./_20200506/README.md).[官方题解](./_20200506/Official_Solution.md) [😭me](./_20200506/me.go)
```$xslt
最低票价
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。
火车票有三种不同的销售方式：
- 一张为期一天的通行证售价为 costs[0] 美元；
- 一张为期七天的通行证售价为 costs[1] 美元；
- 一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。
返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。
```
---
##### 简单.[@20200507](./_20200507/main.go).[README.md](./_20200507/README.md).[官方题解](./_20200507/Official_Solution.md) [😭me](./_20200507/me.go)
```$xslt
另一个树的子树
给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
```
---
##### 中等.[@20200508](./_20200508/main.go).[README.md](./_20200508/README.md).[官方题解](./_20200508/Official_Solution.md) [😄me](./_20200508/me.go)
```$xslt
最大正方形
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
```
---
##### 简单.[@20200509](./_20200509/main.go).[README.md](./_20200509/README.md).[官方题解](./_20200509/Official_Solution.md) [😄me](./_20200509/me.go)
```$xslt
 x 的平方根
实现 `int sqrt(int x)` 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
```
---
##### 中等.[@20200510](./_20200510/main.go).[README.md](./_20200510/README.md).[官方题解](./_20200510/Official_Solution.md) [😄me](./_20200510/me.go)
```$xslt
二叉树的最近公共祖先 
给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
```
---
##### 中等.[@20200511](./_20200511/main.go).[README.md](./_20200511/README.md).[官方题解](./_20200511/Official_Solution.md) [😄me](./_20200511/me.go)
```$xslt
Pow(x, n)
实现 pow(x, n) ，即计算 x 的 n 次幂函数。
```
---
##### 简单.[@20200512](./_20200512/main.go).[README.md](./_20200512/README.md).[官方题解](./_20200512/Official_Solution.md) [😄me](./_20200512/me.go)
```$xslt
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。
```
---
##### 中等.[@20200513](./_20200513/main.go).[README.md](./_20200513/README.md).[官方题解](./_20200513/Official_Solution.md) [😄me](./_20200513/me.go)
```$xslt
二叉树的层序遍历
给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
```
---
##### 简单.[@20200514](./_20200514/main.go).[README.md](./_20200514/README.md).[官方题解](./_20200514/Official_Solution.md) [😄me](./_20200514/me.go)
```$xslt
只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
```
---
##### 中等.[@20200515](./_20200515/main.go).[README.md](./_20200515/README.md).[官方题解](./_20200515/Official_Solution.md) [😄me](./_20200515/me.go)
```$xslt
和为K的子数组
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
```
---
##### 中等.[@20200517](./_20200517/main.go).[README.md](./_20200517/README.md).[官方题解](./_20200517/Official_Solution.md) [😄me](./_20200517/me.go)
```$xslt
课程表 II
现在你总共有 n 门课需要选，记为 0 到 n-1。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]
给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。
可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。
```
---
##### 中等.[@20200518](./_20200518/main.go).[README.md](./_20200518/README.md).[官方题解](./_20200518/Official_Solution.md) [😄me](./_20200518/me.go)
```$xslt
乘积最大子数组
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
```
---
##### 简单.[@20200519](./_20200519/main.go).[README.md](./_20200519/README.md).[官方题解](./_20200519/Official_Solution.md) [😄me](./_20200519/me.go)
```$xslt
验证回文字符串 Ⅱ
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
```
---
##### 中等.[@20200520](./_20200520/main.go).[README.md](./_20200520/README.md).[官方题解](./_20200520/Official_Solution.md) [😄me](./_20200520/me.go)
```$xslt
每个元音包含偶数次的最长子字符串
给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。
```
---
##### 中等.[@20200521](./_20200521/main.go).[README.md](./_20200521/README.md).[官方题解](./_20200521/Official_Solution.md) [😄me](./_20200521/me.go)
```$xslt
最长回文子串
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
```
---
##### 中等.[@20200522](./_20200522/main.go).[README.md](./_20200522/README.md).[官方题解](./_20200522/Official_Solution.md) [😄me](./_20200522/me.go)
```$xslt
从前序与中序遍历序列构造二叉树
根据一棵树的前序遍历与中序遍历构造二叉树。
```
---
##### 困难.[@20200524](./_20200524/main.go).[README.md](./_20200524/README.md).[官方题解](./_20200524/Official_Solution.md) [😄me](./_20200524/me.go)
```$xslt
寻找两个正序数组的中位数
给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。
请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。
你可以假设 nums1 和 nums2 不会同时为空。
```
---
##### 中等.[@20200526](./_20200526/main.go).[README.md](./_20200526/README.md).[官方题解](./_20200526/Official_Solution.md) [😄me](./_20200526/me.go)
```$xslt
寻找重复数
给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。
```
---
##### 中等.[@20200527](./_20200527/main.go).[README.md](./_20200527/README.md).[官方题解](./_20200527/Official_Solution.md) [😄me](./_20200527/me.go)
```$xslt
和可被 K 整除的子数组
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。
```
---
##### 困难.[@20200530](./_20200530/main.go).[README.md](./_20200530/README.md).[官方题解](./_20200530/Official_Solution.md) [😄me](./_20200530/me.go)
```$xslt
柱状图中最大的矩形
给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
求在该柱状图中，能够勾勒出来的矩形的最大面积。
```
---
##### 简单.[@20200531](./_20200531/main.go).[README.md](./_20200531/README.md).[官方题解](./_20200531/Official_Solution.md) [😄me](./_20200531/me.go)
```$xslt
对称二叉树
给定一个二叉树，检查它是否是镜像对称的。
```
---
##### 简单.[@20200601](./_20200601/main.go).[README.md](./_20200601/README.md).[官方题解](./_20200601/Official_Solution.md) [😄me](./_20200601/me.go)
```$xslt
拥有最多糖果的孩子
给你一个数组 `candies` 和一个整数 `extraCandies` ，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目。
对每一个孩子，检查是否存在一种方案，将额外的 `extraCandies` 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。
```
---
##### 中等.[@20200602](./_20200602/main.go).[README.md](./_20200602/README.md).[官方题解](./_20200602/Official_Solution.md) [😄me](./_20200602/me.go)
```$xslt
面试题64. 求1+2+…+n
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```
---
##### 中等.[@20200603](./_20200603/main.go).[README.md](./_20200603/README.md).[官方题解](./_20200603/Official_Solution.md) [😄me](./_20200603/me.go)
```$xslt
新21点
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：
爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？
```
---
##### 中等.[@20200604](./_20200604/main.go).[README.md](./_20200604/README.md).[官方题解](./_20200604/Official_Solution.md) [😄me](./_20200604/me.go)
```$xslt
除自身以外数组的乘积
给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
```
---
##### 简单.[@20200605](./_20200605/main.go).[README.md](./_20200605/README.md).[官方题解](./_20200605/Official_Solution.md) [😄me](./_20200605/me.go)
```$xslt
顺时针打印矩阵
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
```
---
##### 困难.[@20200606](./_20200606/main.go).[README.md](./_20200606/README.md).[官方题解](./_20200606/Official_Solution.md) [😄me](./_20200606/me.go)
```$xslt
最长连续序列
给定一个未排序的整数数组，找出最长连续序列的长度。
要求算法的时间复杂度为 O(n)。
```
---
##### 中等.[@20200608](./_20200608/main.go).[README.md](./_20200608/README.md).[官方题解](./_20200608/Official_Solution.md) [😄me](./_20200608/me.go)
```$xslt
等式方程的可满足性
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]` 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 
```
---
##### 中等.[@20200609](./_20200609/main.go).[README.md](./_20200609/README.md).[官方题解](./_20200609/Official_Solution.md) [😄me](./_20200609/me.go)
```$xslt
把数字翻译成字符串
给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
```
---
##### 简单.[@20200610](./_20200610/main.go).[README.md](./_20200610/README.md).[官方题解](./_20200610/Official_Solution.md) [😄me](./_20200610/me.go)
```$xslt
回文数
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
```
---
##### 中等.[@20200611](./_20200611/main.go).[README.md](./_20200611/README.md).[官方题解](./_20200611/Official_Solution.md) [😄me](./_20200611/me.go)
```$xslt
每日温度
请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。
提示：气温 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。
```
---
##### 中等.[@20200612](./_20200612/main.go).[README.md](./_20200612/README.md).[官方题解](./_20200612/Official_Solution.md) [😄me](./_20200612/me.go)
```$xslt
三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意：答案中不可以包含重复的三元组。
```
---
##### 简单.[@20200613](./_20200613/main.go).[README.md](./_20200613/README.md).[官方题解](./_20200613/Official_Solution.md) [😄me](./_20200613/me.go)
```$xslt
爬楼梯
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
```
---
##### 简单.[@20200615](./_20200615/main.go).[README.md](./_20200615/README.md).[官方题解](./_20200615/Official_Solution.md) [😄me](./_20200615/me.go)
```$xslt
最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 ""。
```
---
##### 中等.[@20200617](./_20200617/main.go).[README.md](./_20200617/README.md).[官方题解](./_20200617/Official_Solution.md) [😄me](./_20200617/me.go)
```$xslt
最佳观光组合
给定正整数数组 `A`，`A[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的距离为 `j - i`。
一对景点`（i < j）`组成的观光组合的得分为`（A[i] + A[j] + i - j）`：景点的评分之和减去它们两者之间的距离。
返回一对观光景点能取得的最高分。
```
---
##### 困难.[@20200618](./_20200618/main.go).[README.md](./_20200618/README.md).[官方题解](./_20200618/Official_Solution.md) [😄me](./_20200618/me.go)
```$xslt
我们从二叉树的根节点 root 开始进行深度优先搜索。
在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。
如果节点只有一个子节点，那么保证该子节点为左子节点。
给出遍历输出 S，还原树并返回其根节点 root。
```
---
##### 简单.[@20200619](./_20200619/main.go).[README.md](./_20200619/README.md).[官方题解](./_20200619/Official_Solution.md) [😄me](./_20200619/me.go)
```$xslt
验证回文串
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
```
---
##### 困难.[@20200621](./_20200621/main.go).[README.md](./_20200621/README.md).[官方题解](./_20200621/Official_Solution.md) [😄me](./_20200621/me.go)
```$xslt
给定一个非空二叉树，返回其最大路径和。
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。
```
---
##### 中等.[@20200622](./_20200622/main.go).[README.md](./_20200622/README.md).[官方题解](./_20200622/Official_Solution.md) [😄me](./_20200622/me.go)
```$xslt
面试题 16.18. 模式匹配
你有两个字符串，即`pattern`和`value`。 
`pattern`字符串由字母`"a"`和`"b"`组成，用于描述字符串中的模式。
例如，字符串`"catcatgocatgo"`匹配模式`"aabab"`（其中`"cat"`是`"a"`，`"go"`是`"b"`），该字符串也匹配像`"a"`、`"ab"`和`"b"`这样的模式。
但需注意`"a"`和`"b"`不能同时表示相同的字符串。编写一个方法判断`value`字符串是否匹配`pattern`字符串。
```
---
##### 简单.[@20200623](./_20200623/main.go).[README.md](./_20200623/README.md).[官方题解](./_20200623/Official_Solution.md) [😄me](./_20200623/me.go)
```$xslt
二进制求和
给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 `1` 和 `0`。
```
---
##### 中等.[@20200624](./_20200624/main.go).[README.md](./_20200624/README.md).[官方题解](./_20200624/Official_Solution.md) [😄me](./_20200624/me.go)
```$xslt
最接近的三数之和
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。
返回这三个数的和。假定每组输入只存在唯一答案。
```
---
##### 中等.[@20200625](./_20200625/main.go).[README.md](./_20200625/README.md).[官方题解](./_20200625/Official_Solution.md) [😄me](./_20200625/me.go)
```$xslt
单词拆分
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
```
---
##### 简单.[@20200626](./_20200626/main.go).[README.md](./_20200626/README.md).[官方题解](./_20200626/Official_Solution.md) [😄me](./_20200626/me.go)
```$xslt
面试题 02.01. 移除重复节点
编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。
```
---
##### 困难.[@20200627](./_20200627/main.go).[README.md](./_20200627/README.md).[官方题解](./_20200627/Official_Solution.md) [😄me](./_20200627/me.go)
```$xslt
缺失的第一个正数
给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。
```
---
##### 中等.[@20200628](./_20200628/main.go).[README.md](./_20200628/README.md).[官方题解](./_20200628/Official_Solution.md) [😄me](./_20200628/me.go)
```$xslt
长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。
```
---
##### 中等.[@20200629](./_20200629/main.go).[README.md](./_20200629/README.md).[官方题解](./_20200629/Official_Solution.md) [😄me](./_20200629/me.go)
```$xslt
数组中的第K个最大元素
在未排序的数组中找到第 `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。
```
---
##### 简单.[@20200630](./_20200630/main.go).[README.md](./_20200630/README.md).[官方题解](./_20200630/Official_Solution.md) [😄me](./_20200630/me.go)
```$xslt
剑指 Offer 09. 用两个栈实现队列
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，
分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
```
---
##### 中等.[@20200701](./_20200701/main.go).[README.md](./_20200701/README.md).[官方题解](./_20200701/Official_Solution.md) [😄me](./_20200701/me.go)
```$xslt
最长重复子数组
给两个整数数组 `A` 和 `B` ，返回两个数组中公共的、长度最长的子数组的长度。
```
---
##### 中等.[@20200702](./_20200702/main.go).[README.md](./_20200702/README.md).[官方题解](./_20200702/Official_Solution.md) [😄me](./_20200702/me.go)
```$xslt
有序矩阵中第K小的元素
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。
```
---
##### 简单.[@20200703](./_20200703/main.go).[README.md](./_20200703/README.md).[官方题解](./_20200703/Official_Solution.md) [😄me](./_20200703/me.go)
```$xslt
将有序数组转换为二叉搜索树
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
```
---
##### 困难.[@20200704](./_20200704/main.go).[README.md](./_20200704/README.md).[官方题解](./_20200704/Official_Solution.md) [😄me](./_20200704/me.go)
```$xslt
最长有效括号
给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。
```
---
##### 困难.[@20200705](./_20200705/main.go).[README.md](./_20200705/README.md).[官方题解](./_20200705/Official_Solution.md) [😄me](./_20200705/me.go)
```$xslt
通配符匹配
给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
```
---
##### 中等.[@20200706](./_20200706/main.go).[README.md](./_20200706/README.md).[官方题解](./_20200706/Official_Solution.md) [😄me](./_20200706/me.go)
```$xslt
不同路径 II
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。
*说明*：m 和 n 的值均不超过 100。
```
---
##### 简单.[@20200707](./_20200707/main.go).[README.md](./_20200707/README.md).[官方题解](./_20200707/Official_Solution.md) [😄me](./_20200707/me.go)
```$xslt
路径总和
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
```
---
##### 简单.[@20200708](./_20200708/main.go).[README.md](./_20200708/README.md).[官方题解](./_20200708/Official_Solution.md) [😄me](./_20200708/me.go)
```$xslt
面试题 16.11. 跳水板
你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。
你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。
返回的长度需要从小到大排列。
```
---
##### 中等.[@20200709](./_20200709/main.go).[README.md](./_20200709/README.md).[官方题解](./_20200709/Official_Solution.md) [😄me](./_20200709/me.go)
```$xslt
面试题 17.13. 恢复空格
哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子"I reset the computer. It still didn’t boot!"已经变成了"iresetthecomputeritstilldidntboot"。
在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。
注意：本题相对原题稍作改动，只需返回未识别的字符数
```
---
##### 中等.[@20200710](./_20200710/main.go).[README.md](./_20200710/README.md).[官方题解](./_20200710/Official_Solution.md) [😄me](./_20200710/me.go)
```$xslt
309. 最佳买卖股票时机含冷冻期
给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
```
---
##### 困难.[@20200711](./_20200711/main.go).[README.md](./_20200711/README.md).[官方题解](./_20200711/Official_Solution.md) [😄me](./_20200711/me.go)
```$xslt
315. 计算右侧小于当前元素的个数
给定一个整数数组 `nums`，按要求返回一个新数组 `counts`。数组 `counts` 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。
```
---
##### 困难.[@20200712](./_20200712/main.go).[README.md](./_20200712/README.md).[官方题解](./_20200712/Official_Solution.md) [😄me](./_20200712/me.go)
```$xslt
174. 地下城游戏
一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 `M x N` 个房间组成的二维网格。
我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；
其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。
*编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。*
```
---
##### 简单.[@20200713](./_20200713/main.go).[README.md](./_20200713/README.md).[官方题解](./_20200713/Official_Solution.md) [😄me](./_20200713/me.go)
```$xslt
350. 两个数组的交集 II
给定两个数组，编写一个函数来计算它们的交集。
```
---
##### 中等.[@20200714](./_20200714/main.go).[README.md](./_20200714/README.md).[官方题解](./_20200714/Official_Solution.md) [😄me](./_20200714/me.go)
```$xslt
120. 三角形最小路径和
给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。
相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
```
---
##### 中等.[@20200715](./_20200715/main.go).[README.md](./_20200715/README.md).[官方题解](./_20200715/Official_Solution.md) [😄me](./_20200715/me.go)
```$xslt
96. 不同的二叉搜索树
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
```
---
##### 中等.[@20200716](./_20200716/main.go).[README.md](./_20200716/README.md).[官方题解](./_20200716/Official_Solution.md) [😄me](./_20200716/me.go)
```$xslt
785. 判断二分图
给定一个无向图`graph`，当这个图为二分图时返回`true`。
如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。
`graph`将会以邻接表方式给出，`graph[i]`表示图中与节点`i`相连的所有节点。每个节点都是一个在`0`到`graph.length-1`之间的整数。这图中没有自环和平行边： 
`graph[i]` 中不存在i，并且`graph[i]`中没有重复的值。
```
---
##### 简单.[@20200717](./_20200717/main.go).[README.md](./_20200717/README.md).[官方题解](./_20200717/Official_Solution.md) [😄me](./_20200717/me.go)
```$xslt
35. 搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
```
---
##### 简单.[@20200720](./_20200720/main.go).[README.md](./_20200720/README.md).[官方题解](./_20200720/Official_Solution.md) [😄me](./_20200720/me.go)
```$xslt
167. 两数之和 II - 输入有序数组
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
```
---
##### 中等.[@20200721](./_20200721/main.go).[README.md](./_20200721/README.md).[官方题解](./_20200721/Official_Solution.md) [😄me](./_20200721/me.go)
```$xslt
95. 不同的二叉搜索树 II
给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。
```
---
##### 简单.[@20200722](./_20200722/main.go).[README.md](./_20200722/README.md).[官方题解](./_20200722/Official_Solution.md) [😄me](./_20200722/me.go)
```$xslt
剑指 Offer 11. 旋转数组的最小数字
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为`1`。
```
---
##### 中等.[@20200723](./_20200723/main.go).[README.md](./_20200723/README.md).[官方题解](./_20200723/Official_Solution.md) [😄me](./_20200723/me.go)
```$xslt
64. 最小路径和
给定一个包含非负整数的 `m x n` 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。
```
---
##### 困难.[@20200725](./_20200725/main.go).[README.md](./_20200725/README.md).[官方题解](./_20200725/Official_Solution.md) [😄me](./_20200725/me.go)
```$xslt
410. 分割数组的最大值
给定一个非负整数数组和一个整数 m，你需要将这个数组分成 m 个非空的连续子数组。设计一个算法使得这 m 个子数组各自和的最大值最小。
```
---
##### 困难.[@20200726](./_20200726/main.go).[README.md](./_20200726/README.md).[官方题解](./_20200726/Official_Solution.md) [😄me](./_20200726/me.go)
```$xslt
329. 矩阵中的最长递增路径
给定一个整数矩阵，找出最长递增路径的长度。
对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。
```
---
##### 简单.[@20200727](./_20200727/main.go).[README.md](./_20200727/README.md).[官方题解](./_20200727/Official_Solution.md) [😄me](./_20200727/me.go)
```$xslt
392. 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。
字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
```
---
##### 简单.[@20200728](./_20200728/main.go).[README.md](./_20200728/README.md).[官方题解](./_20200728/Official_Solution.md) [😄me](./_20200728/me.go)
```$xslt
104. 二叉树的最大深度
给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
```
---
##### 困难.[@20200729](./_20200729/main.go).[README.md](./_20200729/README.md).[官方题解](./_20200729/Official_Solution.md) [😄me](./_20200729/me.go)
```$xslt
LCP 13. 寻宝
我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。
迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 'S' 表示），和唯一的宝藏地点（用 'T' 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 'M' 表示），只有所有机关均被触发，才可以拿到宝藏。
要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 'O' 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。
迷宫中同样有一些墙壁（用 '#' 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 '.' 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。
我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。
```
---
##### 中等.[@20200730](./_20200730/main.go).[README.md](./_20200730/README.md).[官方题解](./_20200730/Official_Solution.md) [😄me](./_20200730/me.go)
```$xslt
343. 整数拆分
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
```
---
##### 简单.[@20200731](./_20200731/main.go).[README.md](./_20200731/README.md).[官方题解](./_20200731/Official_Solution.md) [😄me](./_20200731/me.go)
```$xslt
面试题 08.03. 魔术索引
魔术索引。 在数组`A[0...n-1]`中，有所谓的魔术索引，满足条件`A[i] = i`。
给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回`-1`。
若有多个魔术索引，返回索引值最小的一个。
```
---
##### 中等.[@20200802](./_20200802/main.go).[README.md](./_20200802/README.md).[官方题解](./_20200802/Official_Solution.md) [😄me](./_20200802/me.go)
```$xslt
114. 二叉树展开为链表
给定一个二叉树，原地将它展开为一个单链表。
```
---
##### 简单.[@20200803](./_20200803/main.go).[README.md](./_20200803/README.md).[官方题解](./_20200803/Official_Solution.md) [😄me](./_20200803/me.go)
```$xslt
415. 字符串相加
给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。
```
---
##### 中等.[@20200804](./_20200804/main.go).[README.md](./_20200804/README.md).[官方题解](./_20200804/Official_Solution.md) [😄me](./_20200804/me.go)
```$xslt
415. 字符串相加
你这个学期必须选修 numCourse 门课程，记为 `0` 到 `numCourse-1` 。
在选修某些课程之前需要一些先修课程。 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示他们：`[0,1]`
给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？
```
---
##### 中等.[@20200805](./_20200805/main.go).[README.md](./_20200805/README.md).[官方题解](./_20200805/Official_Solution.md) [😄me](./_20200805/me.go)
```$xslt
337. 打家劫舍 III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，
每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 
如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。
```
---
##### 困难.[@20200806](./_20200806/main.go).[README.md](./_20200806/README.md).[官方题解](./_20200806/Official_Solution.md) [😄me](./_20200806/me.go)
```$xslt
336. 回文对
给定一组唯一的单词， 找出所有不同的索引对`(i, j)`，使得列表中的两个单词， `words[i] + words[j]` ，可拼接成回文串。
```
---
##### 简单.[@20200807](./_20200807/main.go).[README.md](./_20200807/README.md).[官方题解](./_20200807/Official_Solution.md) [😄me](./_20200807/me.go)
```$xslt
100. 相同的树
给定两个二叉树，编写一个函数来检验它们是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
```
---
##### 简单.[@20200810](./_20200810/main.go).[README.md](./_20200810/README.md).[官方题解](./_20200810/Official_Solution.md) [😄me](./_20200810/me.go)
```$xslt
696. 计数二进制子串
给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。
重复出现的子串要计算它们出现的次数。
```
---
##### 中等.[@20200811](./_20200811/main.go).[README.md](./_20200811/README.md).[官方题解](./_20200811/Official_Solution.md) [😄me](./_20200811/me.go)
```$xslt
130. 被围绕的区域
给定一个二维的矩阵，包含 `'X'` 和 `'O'`（字母 `O`）。
找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。
```
---
##### 中等.[@20200812](./_20200812/main.go).[README.md](./_20200812/README.md).[官方题解](./_20200812/Official_Solution.md) [😄me](./_20200812/me.go)
```$xslt
133. 克隆图
给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
图中的每个节点都包含它的值 `val（int）` 和其邻居的列表`（list[Node]）`。
```
---
##### 中等.[@20200813](./_20200813/main.go).[README.md](./_20200813/README.md).[官方题解](./_20200813/Official_Solution.md) [😄me](./_20200813/me.go)
```$xslt
43. 字符串相乘
给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。
```
---
##### 简单.[@20200814](./_20200814/main.go).[README.md](./_20200814/README.md).[官方题解](./_20200814/Official_Solution.md) [😄me](./_20200814/me.go)
```$xslt
20. 有效的括号
给定一个只包括 `'('，')'，'{'，'}'，'['，']'` 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
```
---
##### 简单.[@20200816](./_20200816/main.go).[README.md](./_20200816/README.md).[官方题解](./_20200816/Official_Solution.md) [😄me](./_20200816/me.go)
```$xslt
733. 图像渲染
有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。
将所有有记录的像素点的颜色值改为新的颜色值。
最后返回经过上色渲染后的图像。
```
---
##### 简单.[@20200817](./_20200817/main.go).[README.md](./_20200817/README.md).[官方题解](./_20200817/Official_Solution.md) [😄me](./_20200817/me.go)
```$xslt
110. 平衡二叉树
给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：
一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
```
---
##### 中等.[@20200818](./_20200818/main.go).[README.md](./_20200818/README.md).[官方题解](./_20200818/Official_Solution.md) [😄me](./_20200818/me.go)
```$xslt
109. 有序链表转换二叉搜索树
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
```
---
##### 中等.[@20200819](./_20200819/main.go).[README.md](./_20200819/README.md).[官方题解](./_20200819/Official_Solution.md) [😄me](./_20200819/me.go)
```$xslt
647. 回文子串
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
```
---
##### 中等.[@20200820](./_20200820/main.go).[README.md](./_20200820/README.md).[官方题解](./_20200820/Official_Solution.md) [😄me](./_20200820/me.go)
```$xslt
529. 扫雷游戏
让我们一起来玩扫雷游戏！
给定一个代表游戏板的二维字符矩阵。 
'M' 代表一个未挖出的地雷，
'E' 代表一个未挖出的空方块，
'B' 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，
数字（'1' 到 '8'）表示有多少地雷与这块已挖出的方块相邻，'X' 则表示一个已挖出的地雷。
现在给出在所有未挖出的方块中（'M'或者'E'）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：
如果一个地雷（'M'）被挖出，游戏就结束了- 把它改为 'X'。
如果一个没有相邻地雷的空方块（'E'）被挖出，修改它为（'B'），并且所有和其相邻的未挖出方块都应该被递归地揭露。
如果一个至少与一个地雷相邻的空方块（'E'）被挖出，修改它为数字（'1'到'8'），表示相邻地雷的数量。
如果在此次点击中，若无更多方块可被揭露，则返回面板。
```
---
##### 简单.[@20200821](./_20200821/main.go).[README.md](./_20200821/README.md).[官方题解](./_20200821/Official_Solution.md) [😄me](./_20200821/me.go)
```$xslt
111. 二叉树的最小深度
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明: 叶子节点是指没有子节点的节点。
```
---
##### 困难.[@20200822](./_20200822/main.go).[README.md](./_20200822/README.md).[官方题解](./_20200822/Official_Solution.md) [😄me](./_20200822/me.go)
```$xslt
679. 24 点游戏
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
```
---
##### 困难.[@20200824](./_20200824/main.go).[README.md](./_20200824/README.md).[官方题解](./_20200824/Official_Solution.md) [😄me](./_20200824/me.go)
```$xslt
459. 重复的子字符串
给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。
```
---
##### 中等.[@20200825](./_20200825/main.go).[README.md](./_20200825/README.md).[官方题解](./_20200825/Official_Solution.md) [😄me](./_20200825/me.go)
```$xslt
491. 递增子序列
给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。
```
---
##### 困难.[@20200829](./_20200829/main.go).[README.md](./_20200829/README.md).[官方题解](./_20200829/Official_Solution.md) [😄me](./_20200829/me.go)
```$xslt
214. 最短回文串
给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。
```
---
##### 简单.[@20200830](./_20200830/main.go).[README.md](./_20200830/README.md).[官方题解](./_20200830/Official_Solution.md) [😄me](./_20200830/me.go)
```$xslt
557. 反转字符串中的单词 III
给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
```
---
##### 中等.[@20200902](./_20200902/main.go).[README.md](./_20200902/README.md).[官方题解](./_20200902/Official_Solution.md) [😄me](./_20200902/me.go)
```$xslt
剑指 Offer 20. 表示数值的字符串
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。
```
---
##### 简单.[@20200904](./_20200904/main.go).[README.md](./_20200904/README.md).[官方题解](./_20200904/Official_Solution.md) [😄me](./_20200904/me.go)
```$xslt
257. 二叉树的所有路径
给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
```
---
##### 简单.[@20200906](./_20200906/main.go).[README.md](./_20200906/README.md).[官方题解](./_20200906/Official_Solution.md) [😄me](./_20200906/me.go)
```$xslt
107. 二叉树的层次遍历 II
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
```
---
##### 中等.[@20200907](./_20200907/main.go).[README.md](./_20200907/README.md).[官方题解](./_20200907/Official_Solution.md) [😄me](./_20200907/me.go)
```$xslt
347. 前 K 个高频元素
给定一个非空的整数数组，返回其中出现频率前 k 高的元素。
```
---
##### 中等.[@20200909](./_20200909/main.go).[README.md](./_20200909/README.md).[官方题解](./_20200909/Official_Solution.md) [😄me](./_20200909/me.go)
```$xslt
39. 组合总和
给定一个无重复元素的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
`candidates` 中的数字可以无限制重复被选取。
```
---
##### 中等.[@20200910](./_20200910/main.go).[README.md](./_20200910/README.md).[官方题解](./_20200910/Official_Solution.md) [😄me](./_20200910/me.go)
```$xslt
40. 组合总和 II
给定一个数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
`candidates` 中的每个数字在每个组合中只能使用一次。
```
---
##### 中等.[@20200911](./_20200911/main.go).[README.md](./_20200911/README.md).[官方题解](./_20200911/Official_Solution.md) [😄me](./_20200911/me.go)
```$xslt
216. 组合总和 III
找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。
```
---
##### 简单.[@20200912](./_20200912/main.go).[README.md](./_20200912/README.md).[官方题解](./_20200912/Official_Solution.md) [😄me](./_20200912/me.go)
```$xslt
637. 二叉树的层平均值
给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。
```
---
##### 中等.[@20200913](./_20200913/main.go).[README.md](./_20200913/README.md).[官方题解](./_20200913/Official_Solution.md) [😄me](./_20200913/me.go)
```$xslt
79. 单词搜索
给定一个二维网格和一个单词，找出该单词是否存在于网格中。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
```
---
##### 中等.[@20200914](./_20200914/main.go).[README.md](./_20200914/README.md).[官方题解](./_20200914/Official_Solution.md) [😄me](./_20200914/me.go)
```$xslt
94. 二叉树的中序遍历
给定一个二叉树，返回它的中序 遍历。
```
---
##### 困难.[@20200915](./_20200915/main.go).[README.md](./_20200915/README.md).[官方题解](./_20200915/Official_Solution.md) [😄me](./_20200915/me.go)
```$xslt
37. 解数独
编写一个程序，通过已填充的空格来解决数独问题。
```
---
##### 简单.[@20200916](./_20200916/main.go).[README.md](./_20200916/README.md).[官方题解](./_20200916/Official_Solution.md) [😄me](./_20200916/me.go)
```$xslt
226. 翻转二叉树
翻转一棵二叉树。
```
---
##### 中等.[@20200918](./_20200918/main.go).[README.md](./_20200918/README.md).[官方题解](./_20200918/Official_Solution.md) [😄me](./_20200918/me.go)
```$xslt
47. 全排列 II
给定一个可包含重复数字的序列，返回所有不重复的全排列。
```
---
##### 简单.[@20200919](./_20200919/main.go).[README.md](./_20200919/README.md).[官方题解](./_20200919/Official_Solution.md) [😄me](./_20200919/me.go)
```$xslt
404. 左叶子之和
计算给定二叉树的所有左叶子之和。
```
---
##### 中等.[@20200920](./_20200920/main.go).[README.md](./_20200920/README.md).[官方题解](./_20200920/Official_Solution.md) [😄me](./_20200920/me.go)
```$xslt
78. 子集
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
```
---
##### 简单.[@20200921](./_20200921/main.go).[README.md](./_20200921/README.md).[官方题解](./_20200921/Official_Solution.md) [😄me](./_20200921/me.go)
```$xslt
538. 把二叉搜索树转换为累加树
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，
使得每个节点的值是原来的节点值加上所有大于它的节点值之和。
```
---
##### 简单.[@20200922](./_20200922/main.go).[README.md](./_20200922/README.md).[官方题解](./_20200922/Official_Solution.md) [😄me](./_20200922/me.go)
```$xslt
968. 监控二叉树
给定一个二叉树，我们在树的节点上安装摄像头。
节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。
计算监控树的所有节点所需的最小摄像头数量。
```
---
##### 简单.[@20200923](./_20200923/main.go).[README.md](./_20200923/README.md).[官方题解](./_20200923/Official_Solution.md) [😄me](./_20200923/me.go)
```$xslt
617. 合并二叉树
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。
合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
```
---
##### 简单.[@20200924](./_20200924/main.go).[README.md](./_20200924/README.md).[官方题解](./_20200924/Official_Solution.md) [😄me](./_20200924/me.go)
```$xslt
501. 二叉搜索树中的众数
给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：
- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树
```
---
##### 中等.[@20200928](./_20200928/main.go).[README.md](./_20200928/README.md).[官方题解](./_20200928/Official_Solution.md) [😄me](./_20200928/me.go)
```$xslt
117. 填充每个节点的下一个右侧节点指针 II
```
---
##### 中等.[@20200929](./_20200929/main.go).[README.md](./_20200929/README.md).[官方题解](./_20200929/Official_Solution.md) [😄me](./_20200929/me.go)
```$xslt
145. 二叉树的后序遍历
给定一个二叉树，返回它的 后序 遍历。
```
---
##### 中等.[@20200930](./_20200930/main.go).[README.md](./_20200930/README.md).[官方题解](./_20200930/Official_Solution.md) [😄me](./_20200930/me.go)
```$xslt
701. 二叉搜索树中的插入操作
给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 
输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。
注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。
```
---
##### 简单.[@20201002](./_20201002/main.go).[README.md](./_20201002/README.md).[官方题解](./_20201002/Official_Solution.md) [😄me](./_20201002/me.go)
```$xslt
771. 宝石与石头
给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。 
S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。
```
---
##### 中等.[@20201010](./_20201010/main.go).[README.md](./_20201010/README.md).[官方题解](./_20201010/Official_Solution.md) [😄me](./_20201010/me.go)
```$xslt
142. 环形链表 II
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表。
```
---
##### 简单.[@20201012](./_20201012/main.go).[README.md](./_20201012/README.md).[官方题解](./_20201012/Official_Solution.md) [😄me](./_20201012/me.go)
```$xslt
530. 二叉搜索树的最小绝对差
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
```
---
##### 中等.[@20201013](./_20201013/main.go).[README.md](./_20201013/README.md).[官方题解](./_20201013/Official_Solution.md) [😄me](./_20201013/me.go)
```$xslt
24. 两两交换链表中的节点
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
```
---
##### 中等.[@20201015](./_20201015/main.go).[README.md](./_20201015/README.md).[官方题解](./_20201015/Official_Solution.md) [😄me](./_20201015/me.go)
```$xslt
116. 填充每个节点的下一个右侧节点指针
给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。
```
---
##### 简单.[@20201016](./_20201016/main.go).[README.md](./_20201016/README.md).[官方题解](./_20201016/Official_Solution.md) [😄me](./_20201016/me.go)
```$xslt
977. 有序数组的平方
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
```
---
##### 中等.[@20201018](./_20201018/main.go).[README.md](./_20201018/README.md).[官方题解](./_20201018/Official_Solution.md) [😄me](./_20201018/me.go)
```$xslt
19. 删除链表的倒数第N个节点
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
```
---
##### 简单.[@20201019](./_20201019/main.go).[README.md](./_20201019/README.md).[官方题解](./_20201019/Official_Solution.md) [😄me](./_20201019/me.go)
```$xslt
844. 比较含退格的字符串
给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
```

